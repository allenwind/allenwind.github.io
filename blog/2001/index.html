<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="你好，世界！"><title>Go并发编程总结 | Mr.Feng Blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go并发编程总结</h1><a id="logo" href="/blog/.">Mr.Feng Blog</a><p class="description">NLP、深度学习、机器学习、Python、Go</p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go并发编程总结</h1><div class="post-meta">Aug 12, 2017<span> | </span><span class="category"><a href="/blog/categories/Go/">Go</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go并发特点"><span class="toc-number">1.</span> <span class="toc-text">Go并发特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-number">2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步"><span class="toc-number">3.</span> <span class="toc-text">同步</span></a></li></ol></div></div><div class="post-content"><p>本文总结Go的并发编程。关于Python的并发编程见<a href>Python并发编程总结</a>。关于并发编程的讨论见<a href>为什么需要并发？</a>。</p>
<a id="more"></a>
<p>谈到Go的并发编程，首先要澄清并发（concurrency）和并行（parallesim）的区别。</p>
<ul>
<li>并发： 逻辑上同时处理多个任务的能力</li>
<li>并行：物理上同一时刻处理多个并发任务的能力</li>
</ul>
<p>当我们说一个程序是并发执行时，这个并发是指程序包含多个逻辑上独立的执行块，至于这些执行块如何被操作系统调度执行，程序的管不了的。例如，在单核电脑上，无论操作系统的何种调度算法，任意一时刻也就只有一个执行块爱执行；如果在多核电脑上，同一时刻可以有多个执行块同时执行。也就是说，并发的程序，多个执行块既可以独立并行执行，也可以串行执行。这取决于操作系统和硬件资源。</p>
<p>而并行的程序是多个执行块的同时执行。从调度的角度理解，并行可以看作是并发的特例。要实现程序的并行执行，除了在编程上做处理还需要硬件支持：多主机或者多核CPU。简单说，并行就是并发的最理想的执行模式。这个最理想的状态包括硬件层面和软件层面。硬件层面就如上述的多主机或多核CPU情况。软件层面看实现并发的编程语言的特性。例如Go很容易让多个Goroutine跑在多个CPU上，但Python尽管在多核环境下由于GIL的原因，很难实现并行。关于Python的GIL问题见<a href>Python真的慢吗？</a>。</p>
<p>那么，并发（并行）如何实现？这就是操作系统层面的问题。操作系统或程序运行时通过线程(thread)、进程(process)、协程(coroutine)实现并发，或理想情况下的并行。关于进行、线程、协程的讨论这里不展开了。</p>
<p>如果更严格地讨论并行，那么并行也就粒度之分。例如位级并行（就是常说的32位电脑、64位电脑、8位单片机）、指令级并行、数据级并行、任务级并行。对于应用编程来说，通常只需关心数据级并行和任务级别并行。</p>
<p>最后，引用Rob Pike的经典描述总结上述的讨论（注意英文语境下的理解）：</p>
<p>并发是同一时间应对(dealing with)多件事情的能力。<br>并行是同一时间动手(doing)做多件事情的能力。</p>
<h2 id="Go并发特点"><a href="#Go并发特点" class="headerlink" title="Go并发特点"></a>Go并发特点</h2><ul>
<li>Goroutine</li>
</ul>
<p>Go的并发单元称为Goroutine。Goroutine和Python的Coroutine看似很像，但事实上并不一样的概念。Go运行时会创建多个线程来执行多个Goroutine并发任务，且Goroutine可以被运行时调度到其他线程上执行。这样，Goroutine更像是线程+协程的综合体。或者理解为：Goroutine是能在线程态和协程态间随运行时调度而进行状态切换的综合体。被调度时以协程态存在，执行时以线程态存在。Goroutine在执行时并不是每次都会创建新的线程，运行时会复用已有的线程。</p>
<p>Goroutine自定义栈初始化只有2KB大小，同时还包括函数指针和调用参数。比操作系统线程MB栈级别小得多，因此在简单的机器上可以创建上万个并发单元。Goroutine栈的大小可以在需要时扩容，最大达到GB级别。</p>
<ul>
<li>channel</li>
</ul>
<p>Go鼓励采用CSP通道进行消息传递来代替内存共享，以此实现安全的并发。CSP就是通信顺序进程（Communicating Sequential Processe）模型。该模型由独立的、并发执行的实体组成，实体之间的通信通过消息通道来实现。CSP模型并不关注发送消息的实体，而是关注发送消息时使用的channel。这一点很容易体会，对于消息的接收者来说，它只通过channel获取消息但并不知道该消息来自哪个发生消息的实体。类似的通信模型还有Actor模型，以后在讨论Scala的并发编程时再详细展开。</p>
<p>channel是线程安全的队列，在多个实现进行通信时，无需担心并发所带来的数据不一致问题。</p>
<p>channel还有两种类型，一种是有缓存，另外一中是无缓冲。后面会详细讨论。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Go很容易创建Goroutine，然后让运行时调度执行Goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">"awesome goroutine!"</span>) <span class="comment">// 创建Goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(s)</span><br><span class="line">    &#125;(<span class="string">"awesome goroutine again!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>&#123;&#125; <span class="comment">// 阻塞当前程序以等带所有Goroutine执行完成</span></span><br></pre></td></tr></table></figure>
<p>调用<code>go</code>关键字后并不会阻塞程序，而是接着往下执行。注意<code>go</code>关键字并不是执行并发操作，而是创建一个goroutine并发单元。该并发单元会放到系统队列中，等待调度器指派适合的系统先去执行该单元。</p>
<ul>
<li>简单的例子</li>
</ul>
<p>下面通过一个例子对比Go和Python的并发编程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"Thread&lt;&#123;&#125;"</span>.format(threading.current_thread().ident), time.ctime())</span><br><span class="line">        time.sleep(interval)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = threading.Thread(target=task, args=(<span class="number">1</span>,))</span><br><span class="line">    task2 = threading.Thread(target=task, args=(<span class="number">2</span>,))</span><br><span class="line"></span><br><span class="line">    task1.start()</span><br><span class="line">    task2.start()</span><br><span class="line"></span><br><span class="line">    task1.join()</span><br><span class="line">    task2.join() // 主线程等待task1、task2退出</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>使用Go改写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(interval <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"goroutine1"</span>, time.Now())</span><br><span class="line">        time.Sleep(interval * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> task(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> task(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    selec&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>阻塞main函数</li>
</ul>
<p>在等待Goroutine执行完毕，main函数不能退出，可以使用一定的技巧阻塞main函数所在的Goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"goroutine quit."</span>)</span><br><span class="line">        <span class="built_in">close</span>(quit)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"main wait..."</span>)</span><br><span class="line">    &lt;-quit</span><br><span class="line">    fmt.Println(<span class="string">"main quit..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用<code>struct{}</code>空结构创建channl是应为其初始化后占用空间为零，指向<code>runtime.ZeroBase</code>。这是一种惯用方法。除了关闭通道外，还有往通道上传入数据也可以解除阻塞。这里传入空结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"goroutine quit."</span>)</span><br><span class="line">        <span class="built_in">close</span>(quit)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"main wait..."</span>)</span><br><span class="line">    &lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"main quit..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于channel更多技巧在后面会详述。</p>
<ul>
<li>Goroutine和defer</li>
</ul>
<p>在Goroutine中依然可以使用defer语句，通过defer注册的函数会在Goroutine退出前执行。<br>Goroutine会像defer一样，因延迟执行，会在创建时立即计算并复制参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>退出Goroutine</li>
</ul>
<p>某些情况下需要Goroutine退出，可以使用<code>runtime.Goexit</code>函数·。该函数立即终止当前的任务，运行时确保所有注册的延时调用都会被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">"will execute in defer"</span>)</span><br><span class="line"></span><br><span class="line">        runtime.Goexit()</span><br><span class="line">        fmt.Println(<span class="string">"never execute"</span>) <span class="comment">// 不会执行</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果是在main函数中调用<code>Goexit</code>，它会等待其他任务结束，然后进程直接崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"main defer"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"goroutine start..."</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"main func wait..."</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    runtime.Goexit()</span><br><span class="line">    fmt.Println(<span class="string">"main exit..."</span>)</span><br></pre></td></tr></table></figure>
<p>如果调用标准库函数<code>os.Exit</code>可直接终止进程，不会执行defer注册的函数。</p>
<ul>
<li>让出执行线程</li>
</ul>
<p>让出当前线程类似Java中的<code>Thread.yield</code>。Go中执行<code>runtime.Gosched</code>后，当前任务会放回队列中，等待下次调度时恢复执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; exit&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">"goroutine-1:"</span>, i)</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; exit&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            fmt.Println(<span class="string">"goroutine-2"</span>, i)</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-exit</span><br><span class="line">    &lt;-exit</span><br></pre></td></tr></table></figure>
<p>Goroutine在退出前会执行defer登记的函数。</p>
<ul>
<li>GOMAXPROCS</li>
</ul>
<p><code>runtime.GOMAXPROCS</code>可以修改运行时创建的线程数，默认是CPU核心数。通过一个例子体验并行计算。我当前笔记本是双核四线程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语法上，Go进行并发编程简介多了。是不是对Go的并发编程有点小兴奋？系好安全带，马上开车！</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>Go中，Goroutine间同步的操作有大部分都包含在标准包<code>sync</code>中。本部分详述Goroutine间的同步方法，包括Go本身的并发特性上的同步和<code>sync</code>的使用。</p>
<p><code>sync</code>包中包括类型有：</p>
<p>条件变量：<code>Cond</code> 类似于Python的<code>threading.Condition</code><br>互斥锁：<code>Mutex</code> 类似于Python的<code>threading.Lock</code><br>读写锁：<code>RWMutex</code> 类似于Python的<code>threading.Lock</code>，但不分读写操作</p>
<p>Python <code>Threading</code>模块中没有的同步操作：<code>Pool</code>, <code>Once</code>, <code>WaitGroup</code></p>
<p>上述方法接下来一一讲解。Go并没有信号量Semaphore，但不难实现，本节结尾会给出实现方法。</p>
<ul>
<li>Mutex</li>
</ul>
<p><code>sync.Mutex</code>是互斥锁，类似<code>threading.Lock</code>。该类型初始化处于unlock状态。下面以实现线程安全的并发字典为例。当然，这种方法并不是最好的实现方式，仅作例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcurrentMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">    mutex *sync.Mutex <span class="comment">// 为了让该例子直观，这里不采用匿名字段。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ConcurrentMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> value, ok := m.data[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, ok</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ConcurrentMap)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ConcurrentMap)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    <span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    cmap := &amp;ConcurrentMap&#123;&#125;</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(_id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            key := <span class="string">"goroutine-"</span> + _id</span><br><span class="line">            value := <span class="string">"value-"</span> + _id</span><br><span class="line">            cmap[key] = value</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(_id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            key := <span class="string">"goroutine-"</span> + _id</span><br><span class="line">            value, ok := cmap[key]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                fmt.Println(key, <span class="string">"get"</span>, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;-wait</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RWMutex</li>
</ul>
<p><code>Mutex</code>锁对于ConcurrentMap的粒度太大。可以细化锁的粒度，把读写分离，分别用不同粒度的锁进行加锁。在数据库并发控制，读写锁也有别名：共享锁、排他锁。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>锁的影响范围</th>
<th>别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享锁</td>
<td>其他连接可以读取数据但不能修改数据</td>
<td>读锁</td>
</tr>
<tr>
<td>排他锁</td>
<td>其他连接无法读取数据，也不能修改数据</td>
<td>写锁</td>
</tr>
</tbody>
</table>
</div>
<p><code>sync.RWMutex</code>中<code>Lock</code>和<code>Unlock</code>分别获取和释放写锁。<code>RLock</code>和<code>RUnlock</code>分别获取和释放读锁。</p>
<p>代码参看上面，这里只修改加锁部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcurrentMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">    mutex *sync.RWMutex <span class="comment">// 为了让该例子直观，这里不采用匿名字段。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ConcurrentMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    m.mutex.RLock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.RUnlock()</span><br><span class="line">    <span class="keyword">if</span> value, ok := m.data[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value, ok</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ConcurrentMap)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ConcurrentMap)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    <span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对使用<code>Mutex</code>和<code>RWMutex</code>做性能测试对比。测试代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>WaitGroup</p>
</li>
<li><p>Once </p>
</li>
<li><p>Pool</p>
</li>
<li><p>Cond</p>
</li>
<li><p>Semaphore</p>
</li>
</ul>
<p>Go中并没有信号量Semaphore，但通过内置类型可以轻易实现Semaphore。这里以channel为例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Semaphore)</span> <span class="title">acquire</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Semaphore)</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSemaphore</span><span class="params">(value <span class="keyword">uint</span>)</span> <span class="title">Semaphore</span></span> &#123;</span><br><span class="line">    <span class="comment">// 原则上，value值不能为负数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(Semaphore, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := NewSemaphore(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.acquire()</span><br><span class="line">        <span class="keyword">defer</span> s.release()</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"goroutine 1"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.acquire()</span><br><span class="line">        <span class="keyword">defer</span> s.release()</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"goroutine 2"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"wait here"</span>)</span><br><span class="line">    s.acquire()</span><br><span class="line">    fmt.Println(<span class="string">"acquire semaphore success"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结构如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span> here</span><br><span class="line">goroutine 1</span><br><span class="line">acquire semaphore success</span><br><span class="line">goroutine 2</span><br></pre></td></tr></table></figure>
<p>转载请包括本文地址：<a href="../2001">https://allenwind.github.io/blog/2001</a><br>更多文章请参考：<a href="../archives/">https://allenwind.github.io/blog/archives/</a></p>
</div><div class="tags"><a href="/blog/tags/Go/">Go</a><a href="/blog/tags/并发编程/">并发编程</a></div><div class="post-nav"><a class="pre" href="/blog/1963/">strcpy原理及其实现思路</a><a class="next" href="/blog/1923/">Linux下Python创建守护进程通用类</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://allenwind.github.io/blog"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/NLP/">NLP</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据结构和算法/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/机器学习深度学习/">机器学习深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/记录/">记录</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/算法/" style="font-size: 15px;">算法</a> <a href="/blog/tags/C/" style="font-size: 15px;">C</a> <a href="/blog/tags/Python/" style="font-size: 15px;">Python</a> <a href="/blog/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/blog/tags/C语言/" style="font-size: 15px;">C语言</a> <a href="/blog/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/blog/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/blog/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/blog/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/blog/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/blog/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/blog/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/blog/tags/sudo/" style="font-size: 15px;">sudo</a> <a href="/blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/blog/tags/git/" style="font-size: 15px;">git</a> <a href="/blog/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/blog/tags/Git/" style="font-size: 15px;">Git</a> <a href="/blog/tags/gcc/" style="font-size: 15px;">gcc</a> <a href="/blog/tags/Systemd/" style="font-size: 15px;">Systemd</a> <a href="/blog/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/blog/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/blog/tags/网络/" style="font-size: 15px;">网络</a> <a href="/blog/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/blog/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/blog/tags/记录/" style="font-size: 15px;">记录</a> <a href="/blog/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/blog/tags/Go/" style="font-size: 15px;">Go</a> <a href="/blog/tags/go/" style="font-size: 15px;">go</a> <a href="/blog/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/blog/tags/ARC/" style="font-size: 15px;">ARC</a> <a href="/blog/tags/Java/" style="font-size: 15px;">Java</a> <a href="/blog/tags/剑指Offer/" style="font-size: 15px;">剑指Offer</a> <a href="/blog/tags/函数式/" style="font-size: 15px;">函数式</a> <a href="/blog/tags/搜索引擎/" style="font-size: 15px;">搜索引擎</a> <a href="/blog/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/blog/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/blog/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/blog/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/blog/tags/并发/" style="font-size: 15px;">并发</a> <a href="/blog/tags/装饰器/" style="font-size: 15px;">装饰器</a> <a href="/blog/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/blog/tags/数学/" style="font-size: 15px;">数学</a> <a href="/blog/tags/度量/" style="font-size: 15px;">度量</a> <a href="/blog/tags/时间序列/" style="font-size: 15px;">时间序列</a> <a href="/blog/tags/投资/" style="font-size: 15px;">投资</a> <a href="/blog/tags/概率/" style="font-size: 15px;">概率</a> <a href="/blog/tags/统计/" style="font-size: 15px;">统计</a> <a href="/blog/tags/信息论/" style="font-size: 15px;">信息论</a> <a href="/blog/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/blog/tags/贝叶斯/" style="font-size: 15px;">贝叶斯</a> <a href="/blog/tags/最小二乘法/" style="font-size: 15px;">最小二乘法</a> <a href="/blog/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/blog/tags/变分推断/" style="font-size: 15px;">变分推断</a> <a href="/blog/tags/随机/" style="font-size: 15px;">随机</a> <a href="/blog/tags/采样/" style="font-size: 15px;">采样</a> <a href="/blog/tags/不等式/" style="font-size: 15px;">不等式</a> <a href="/blog/tags/光滑/" style="font-size: 15px;">光滑</a> <a href="/blog/tags/逼近/" style="font-size: 15px;">逼近</a> <a href="/blog/tags/分布/" style="font-size: 15px;">分布</a> <a href="/blog/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/blog/tags/特征工程/" style="font-size: 15px;">特征工程</a> <a href="/blog/tags/集成学习/" style="font-size: 15px;">集成学习</a> <a href="/blog/tags/分类/" style="font-size: 15px;">分类</a> <a href="/blog/tags/证明/" style="font-size: 15px;">证明</a> <a href="/blog/tags/交叉验证/" style="font-size: 15px;">交叉验证</a> <a href="/blog/tags/词向量/" style="font-size: 15px;">词向量</a> <a href="/blog/tags/信息/" style="font-size: 15px;">信息</a> <a href="/blog/tags/损失函数/" style="font-size: 15px;">损失函数</a> <a href="/blog/tags/回归/" style="font-size: 15px;">回归</a> <a href="/blog/tags/正则化/" style="font-size: 15px;">正则化</a> <a href="/blog/tags/指标/" style="font-size: 15px;">指标</a> <a href="/blog/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/blog/tags/Embedding/" style="font-size: 15px;">Embedding</a> <a href="/blog/tags/神经网络/" style="font-size: 15px;">神经网络</a> <a href="/blog/tags/Transformer/" style="font-size: 15px;">Transformer</a> <a href="/blog/tags/Attention/" style="font-size: 15px;">Attention</a> <a href="/blog/tags/对抗训练/" style="font-size: 15px;">对抗训练</a> <a href="/blog/tags/分词/" style="font-size: 15px;">分词</a> <a href="/blog/tags/并行/" style="font-size: 15px;">并行</a> <a href="/blog/tags/文本分类/" style="font-size: 15px;">文本分类</a> <a href="/blog/tags/NER/" style="font-size: 15px;">NER</a> <a href="/blog/tags/HMM/" style="font-size: 15px;">HMM</a> <a href="/blog/tags/图/" style="font-size: 15px;">图</a> <a href="/blog/tags/概率图/" style="font-size: 15px;">概率图</a> <a href="/blog/tags/可视化/" style="font-size: 15px;">可视化</a> <a href="/blog/tags/RNN/" style="font-size: 15px;">RNN</a> <a href="/blog/tags/LSTM/" style="font-size: 15px;">LSTM</a> <a href="/blog/tags/梯度/" style="font-size: 15px;">梯度</a> <a href="/blog/tags/注意力/" style="font-size: 15px;">注意力</a> <a href="/blog/tags/序列编码/" style="font-size: 15px;">序列编码</a> <a href="/blog/tags/BERT/" style="font-size: 15px;">BERT</a> <a href="/blog/tags/注意力机制/" style="font-size: 15px;">注意力机制</a> <a href="/blog/tags/磁盘故障/" style="font-size: 15px;">磁盘故障</a> <a href="/blog/tags/优化/" style="font-size: 15px;">优化</a> <a href="/blog/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/blog/tags/卷积/" style="font-size: 15px;">卷积</a> <a href="/blog/tags/调参/" style="font-size: 15px;">调参</a> <a href="/blog/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/blog/tags/web/" style="font-size: 15px;">web</a> <a href="/blog/tags/socket/" style="font-size: 15px;">socket</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/16228/">分析与拓展：Transformer中的MultiHeadAttention为什么使用scaled？</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/16113/">Tensorflow的多卡训练：原理和实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/16051/">机器学习之分类问题的评估指标总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/16003/">天马行空：设计自己的激活函数</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15887/">函数光滑近似（4）：Heaviside step函数及其应用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15205/">引入参数控制softmax的smooth程度</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15110/">分析与拓展：多分类模型的输出为什么使用softmax？</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14990/">一种基于光滑逼近的正态分布采样法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14721/">GELU由来：从狄拉克函数到GELU激活函数</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14465/">Lp范数的上下界分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/allenwind" title="My GitHub" target="_blank">My GitHub</a><ul></ul><a href="http://www.arxiv-sanity.com/" title="arxiv-sanity" target="_blank">arxiv-sanity</a><ul></ul><a href="https://arxiv.org/" title="arxiv.org" target="_blank">arxiv.org</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/blog/." rel="nofollow">Mr.Feng Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>