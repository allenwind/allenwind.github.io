<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="你好，世界！"><title>Python线程并发编程总结 | Mr.Feng Blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python线程并发编程总结</h1><a id="logo" href="/blog/.">Mr.Feng Blog</a><p class="description">NLP、深度学习、机器学习、Python、Go</p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python线程并发编程总结</h1><div class="post-meta">Dec 20, 2017<span> | </span><span class="category"><a href="/blog/categories/Python/">Python</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的相关概念"><span class="toc-number">2.</span> <span class="toc-text">线程的相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的创建和使用"><span class="toc-number">3.</span> <span class="toc-text">线程的创建和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#守护线程"><span class="toc-number">4.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程本地"><span class="toc-number">5.</span> <span class="toc-text">线程本地</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间通信"><span class="toc-number">6.</span> <span class="toc-text">线程间通信</span></a></li></ol></div></div><div class="post-content"><p>总结Python的并发编程~</p>
<a id="more"></a>
<p>以前写得并发编程常用于网络资源获取、数据库查询上，例如网络爬虫、并发同步MongoDB和MySQL数据。并发在I/O上有极大的好处。通常情况下，网络请求、磁盘读写等I/O的时间周期是CPU时钟周期的一百万倍，程序在执行时大部分时间都浪费在I/O等待上。CPU、内存、网络的时间对比如图：</p>
<p>由于项目原因，觉得有必要总结下。于是，就在博客上写下线程并发编程，未来可能会总结协程并发（好吧，我挖的坑）</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文的重点不是Python线程库threading的使用（具体的使用可以看官方文档），而是关注线程的原理、使用技巧和与线程并发编程相关的各类话题。</p>
<h2 id="线程的相关概念"><a href="#线程的相关概念" class="headerlink" title="线程的相关概念"></a>线程的相关概念</h2><p>本节内容：</p>
<ol>
<li>线程id、线程的常量、竞争条件、临界区、线程安全和非线程安全、死锁</li>
<li>内核级线程和用户级线程</li>
<li>线程的内存模型</li>
<li>线程的底层实现</li>
<li>线程的有限状态机</li>
<li>不同语言的线程实现的差异</li>
<li>Future、Callable</li>
</ol>
<p>Python、Golang、Java、C</p>
<h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><p>Python线程的创建有三种方法：（1）通过继承threading.Thread类，重写run方法（2）实例化threading.Thread（3）使用底层库_thread。下面具体说明。</p>
<ul>
<li>通过继承的方法</li>
</ul>
<p>假定我们要实现一个线程，能定时打印出当前时间。我们只需要两点：（1）把类初始化的参数在<strong>init</strong>方法中传入（2）重写run方法—线程的运行逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span> <span class="comment"># 该类要初始化的参数</span></span><br><span class="line">        self.interval = interval</span><br><span class="line">        super().__init__() <span class="comment"># 初始化父类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span> <span class="comment"># 线程的运行逻辑在这里</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            print(datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>), flush=<span class="literal">True</span>) <span class="comment"># flush是指定清空缓冲，让字符直接在终端显示</span></span><br><span class="line">            time.sleep(self.interval) <span class="comment"># 每次循环指定休眠时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    timer = Timer(<span class="number">1</span>)</span><br><span class="line">    timer.start() <span class="comment"># 调用start方法触发上面重写的run方法的逻辑</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2017-08-19 23:25:35</span><br><span class="line">2017-08-19 23:25:36</span><br><span class="line">2017-08-19 23:25:37</span><br><span class="line">2017-08-19 23:25:38</span><br><span class="line">2017-08-19 23:25:39</span><br><span class="line">2017-08-19 23:25:40</span><br><span class="line">2017-08-19 23:25:41</span><br><span class="line">2017-08-19 23:25:42</span><br><span class="line">2017-08-19 23:25:43</span><br><span class="line">2017-08-19 23:25:44</span><br><span class="line">2017-08-19 23:25:45</span><br><span class="line">2017-08-19 23:25:46</span><br><span class="line">2017-08-19 23:25:47</span><br><span class="line">2017-08-19 23:25:48</span><br></pre></td></tr></table></figure>
<p>上面实现的类的一个明显缺点是无法让启动了的线程停下来，文章后面会讲到如何处理这个问题的。</p>
<ul>
<li>通过实例化threading.Thread来创建线程</li>
</ul>
<p>功能依旧是上面的一个心跳时钟</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>), flush=<span class="literal">True</span>)</span><br><span class="line">        time.sleep(interval)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    interval = <span class="number">1</span></span><br><span class="line">    task = threading.Thread(target=timer, args=(interval,))</span><br><span class="line">    task.start()</span><br></pre></td></tr></table></figure>
<p><code>target</code>是指定要在线程上执行的代码逻辑。<code>args</code>是传入target所指定的函数的参数即timer函数args要以元组的方式表示，即便是只有一个参数的情况。</p>
<p>有时候我们并不想通过args传入参数，我们还可以通过偏函数的方法提前给函数指定参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>), flush=<span class="literal">True</span>)</span><br><span class="line">        time.sleep(interval)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    timer_with_args = functools.partial(timer, interval=<span class="number">1</span>) <span class="comment"># 通过偏函数指定timer的参数</span></span><br><span class="line">    task = threading.Thread(target=timer_with_args) <span class="comment"># 参数已经传入了，不同通过args传入</span></span><br><span class="line">    task.start()</span><br></pre></td></tr></table></figure>
<p>通过threading库的源码我们可以看看Thread还有哪些参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group=None, target=None, name=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 args=<span class="params">()</span>, kwargs=None, *, daemon=None)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> group <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">"group argument must be None for now"</span></span><br><span class="line">        <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125;</span><br><span class="line">        self._target = target</span><br><span class="line">        self._name = str(name <span class="keyword">or</span> _newname())</span><br><span class="line">        self._args = args</span><br><span class="line">        self._kwargs = kwargs</span><br><span class="line">        <span class="keyword">if</span> daemon <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._daemonic = daemon</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._daemonic = current_thread().daemon</span><br><span class="line">        self._ident = <span class="literal">None</span></span><br><span class="line">        self._tstate_lock = <span class="literal">None</span></span><br><span class="line">        self._started = Event()</span><br><span class="line">        self._is_stopped = <span class="literal">False</span></span><br><span class="line">        self._initialized = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># sys.stderr is not stored in the class like</span></span><br><span class="line">        <span class="comment"># sys.exc_info since it can be changed between instances</span></span><br><span class="line">        self._stderr = _sys.stderr</span><br><span class="line">        <span class="comment"># For debugging and _after_fork()</span></span><br><span class="line">        _dangling.add(self)</span><br></pre></td></tr></table></figure>
<p>从源码可以知道，我们还可以通过关键字参数给我们的target函数传入参数。另外还可指定线程是否为守护线程。守护线程可以到达的效果是：当有多个线程在并发执行时，所有的非守护线程都执行完毕退出了，那么解析器不管有多小守护线程，不管它们在执行什么，都直接退出。这会即将讲到。</p>
<p>以上就是实现线程的两种方法：实例化Thread类、继承Thread重写run方法。那么问题来了，到底什么时候使用前者，什么时候使用后者。一般惯例如下：</p>
<p>当我们要实现的线程的执行流程很复杂，需要分解为小的函数，我们就可以：采用继承Thread重写run方法。这样我们把复杂的功能分解为该类的方法，有run方法调用这些方法从而构成复杂的多线程调用链。模板如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># deal with args kwargs</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_task1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># task2 function</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_task2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># task2 function</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._task1()</span><br><span class="line">        self._task2()</span><br></pre></td></tr></table></figure>
<p>而如果多线程执行的函数相对简单，一个函数就可以实现，通过实例化Thread的方法就很方便了。例如上面的timer例子。</p>
<p>标准库threading中有一个Timer类，其实现的功能和心跳时钟相似。Timer类会在启动后的指定时间到达的一刻运行传入的func函数。通常可以把这个类用于一次性的定时任务，例如定时清理日志。例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"args params"</span>, args)</span><br><span class="line">    print(<span class="string">"kwargs params"</span>, kwargs)</span><br><span class="line">    print(<span class="string">"I quit now!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    interval = <span class="number">1</span></span><br><span class="line">    timer = threading.Timer(interval, task, args=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    timer.start()</span><br></pre></td></tr></table></figure>
<p>另外，还有一种不常用的方法。使用_thread（Python3）中的<code>start_new_thread</code>函数。但这个函数来自底层库_thread，并不常用。在实际开发中应该优先使用threading库中的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>), flush=<span class="literal">True</span>)</span><br><span class="line">        time.sleep(interval)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    thread_id = _thread.start_new_thread(timer, (<span class="number">1</span>,))</span><br></pre></td></tr></table></figure>
<p>如果我们需要更细粒度控制线程以及并发原语，我们可以使用_thread这个库。</p>
<p>结合Python的装饰器语法糖，我们甚至可以创建一线程装饰器，被装饰的函数或类在新的线程中运行。这一实现在<strong>技巧</strong>部分出现。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>关于守护进程参考历史文章：<a href="https://allenwind.github.io/2017/08/11/Linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">Linux下创建守护进程</a></p>
<p>守护线程和守护进程的概念类似。后者是进程在后台（没有终端）运行，前者是协助其他线程运行。当进程中的所有非守护线程已经运行完成（回想线程状态图），进程就直接退出，而不等待守护线程。使用守护线程的情景是：业务需要多个线程执行，其中一部分线程并不参与实际业务流程只是协助执行业务流程的线程，当执行业务流程的线程退出了，协助业务流程的线程就没有运行的意义了，它不应该让进程（主线程）等待它们退出。那么可以把这类协助目的的线程设置为守护线程。例如：先前的项目<a href>文件系统搜索引擎</a>，上面运行着两类线程，一类是web服务线程，一类是文件系统扫描线程。 </p>
<h2 id="线程本地"><a href="#线程本地" class="headerlink" title="线程本地"></a>线程本地</h2><p>本节包括两部分：</p>
<ol>
<li>threading.local</li>
<li>Flask</li>
</ol>
<p><code>threading.local</code>为每个线程创建一个对其他线程不可见的对象，用以存储当前线程的数据。<code>threading.local</code>本质上是字典数据结构，字典的键为线程唯一的id，可以通过`threading.current_thread().ident获取，字段的值为线程id对应的线程存储的对象空间。</p>
<p>下面举一个例子，两个线程分别保存以自己命名的数据，然后试图读取自己和另外一线程的数据，以此考察<code>threading.local</code>的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(_id, local)</span>:</span></span><br><span class="line">    <span class="comment"># tid = threading.current_thread().ident // 获取当前线程id</span></span><br><span class="line">    thread_id = <span class="string">"thread_&#123;&#125;"</span>.format(_id)</span><br><span class="line">    setattr(local, thread_id, _id)</span><br><span class="line"></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = local.thread_1</span><br><span class="line">        print(thread_id, <span class="string">"got thread_id"</span>, value)</span><br><span class="line">    <span class="keyword">except</span> AttributeError <span class="keyword">as</span> err:</span><br><span class="line">        print(thread_id, <span class="string">"can't see local.thread_1"</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = local.thread_2</span><br><span class="line">        print(thread_id, <span class="string">"got thread_id"</span>, value)</span><br><span class="line">    <span class="keyword">except</span> AttributeError <span class="keyword">as</span> err:</span><br><span class="line">        print(thread_id, <span class="string">"can't see local.thread_2"</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    local = threading.local()</span><br><span class="line">    thread_1 = threading.Thread(target=task, args=(<span class="number">1</span>, local))</span><br><span class="line">    thread_2 = threading.Thread(target=task, args=(<span class="number">2</span>, local))</span><br><span class="line"></span><br><span class="line">    thread_1.start()</span><br><span class="line">    thread_2.start()</span><br><span class="line"></span><br><span class="line">    thread_1.join()</span><br><span class="line">    thread_2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行程序输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_2 can<span class="string">'t see local.thread_1</span></span><br><span class="line"><span class="string">thread_2 got thread_id 2</span></span><br><span class="line"><span class="string">thread_1 got thread_id 1</span></span><br><span class="line"><span class="string">thread_1 can'</span>t see local.thread_2</span><br></pre></td></tr></table></figure>
<p>可以验证，线程无法看到其他线程在<code>threading.local</code>上保存的变量，起到隔离作用。</p>
<p><code>threading.local</code>本身是一个类，该类源自<code>_thread._local</code>。可以通过继承<code>threading.local</code>来实现更丰富的控制或接口。下面例子通过继承<code>threading.local</code>为其添加部分dict接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_dunder</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="string">"""Returns True if a __dunder__ name, False otherwise."""</span></span><br><span class="line">    <span class="keyword">return</span> (name[:<span class="number">2</span>] == name[<span class="number">-2</span>:] == <span class="string">'__'</span> <span class="keyword">and</span></span><br><span class="line">            name[<span class="number">2</span>:<span class="number">3</span>] != <span class="string">'_'</span> <span class="keyword">and</span></span><br><span class="line">            name[<span class="number">-3</span>:<span class="number">-2</span>] != <span class="string">'_'</span> <span class="keyword">and</span></span><br><span class="line">            len(name) &gt; <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_sunder</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="string">"""Returns True if a _sunder_ name, False otherwise."""</span></span><br><span class="line">    <span class="keyword">return</span> (name[<span class="number">0</span>] == name[<span class="number">-1</span>] == <span class="string">'_'</span> <span class="keyword">and</span></span><br><span class="line">            name[<span class="number">1</span>:<span class="number">2</span>] != <span class="string">'_'</span> <span class="keyword">and</span></span><br><span class="line">            name[<span class="number">-2</span>:<span class="number">-1</span>] != <span class="string">'_'</span> <span class="keyword">and</span></span><br><span class="line">            len(name) &gt; <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictLocal</span><span class="params">(threading.local)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            self[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self, key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> _is_dunder(key) <span class="keyword">or</span> _is_sunder(key):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"key is dunder or sunder"</span>)</span><br><span class="line">        setattr(self, key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            delattr(self, key)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dir(self):</span><br><span class="line">            <span class="keyword">if</span> _is_dunder(item) <span class="keyword">or</span> _is_sunder(item) <span class="keyword">or</span> item == <span class="string">'items'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            data[item] = self[item]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hasattr(self, key)</span><br></pre></td></tr></table></figure>
<p>这个类比<code>threading.local</code>的使用方便多了。<code>_is_dunder</code>和<code>_is_sunder</code>方法用于检测私有方法或被保护方法。通常我们不会以这两类名字命名线程local变量。</p>
<p>上面讨论了<code>threading.local</code>的实现原理，下面实现一个简单的local。注意递归问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLocal</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self._data = defaultdict(dict)</span><br><span class="line">        _id = threading.current_thread().ident</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            self._data[_id][key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        _id = threading.current_thread().ident</span><br><span class="line">        <span class="keyword">return</span> self._data[_id][key] <span class="comment"># 这里并没有做一次处理，和threading.local一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        _id = threading.current_thread().ident</span><br><span class="line">        self._data[_id][key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        _id = threading.current_thread().ident</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self._data[_id]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            _id = threading.current_thread().ident</span><br><span class="line">            <span class="keyword">del</span> self._data[_id][key]</span><br></pre></td></tr></table></figure>
<p>我们依旧使用上面的例子，但把<code>threading.local</code>改为<code>SimpleLocal</code>。由于数据结构上的差异，修改了部分细节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(_id, local)</span>:</span></span><br><span class="line">    <span class="comment"># tid = threading.current_thread().ident // 获取当前线程id</span></span><br><span class="line">    thread_id = <span class="string">"thread_&#123;&#125;"</span>.format(_id)</span><br><span class="line">    local[thread_id] = _id <span class="comment"># setattr(local, thread_id, _id)</span></span><br><span class="line"></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = local[<span class="string">"thread_1"</span>]</span><br><span class="line">        print(thread_id, <span class="string">"got thread_id"</span>, value)</span><br><span class="line">    <span class="keyword">except</span> KeyError <span class="keyword">as</span> err:</span><br><span class="line">        print(thread_id, <span class="string">"can't see local.thread_1"</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = local[<span class="string">"thread_2"</span>]</span><br><span class="line">        print(thread_id, <span class="string">"got thread_id"</span>, value)</span><br><span class="line">    <span class="keyword">except</span> KeyError <span class="keyword">as</span> err:</span><br><span class="line">        print(thread_id, <span class="string">"can't see local.thread_2"</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    local = SimpleLocal() <span class="comment"># 类似threading.local()</span></span><br><span class="line">    thread_1 = threading.Thread(target=task, args=(<span class="number">1</span>, local))</span><br><span class="line">    thread_2 = threading.Thread(target=task, args=(<span class="number">2</span>, local))</span><br><span class="line"></span><br><span class="line">    thread_1.start()</span><br><span class="line">    thread_2.start()</span><br><span class="line"></span><br><span class="line">    thread_1.join()</span><br><span class="line">    thread_2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果依旧不变。</p>
<p>那么<code>threading.local</code>有什么用呢？下面通过Flask中的上下文Context来举例说明。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Python进行线程间通信有两类方法：1. 共享变量，通过同步原语实现并发访问控制。2. 线程安全的队列，把数据发送到队列中，另一方线程取出。前者在下一节详述。后者在实现上也有两种方法：（1）标准库中的<code>queue</code>模块的实现方法，使用面向对象方式，在线程不安全的队列上添加同步原语。（2）通过CAS实现无锁队列。从底层角度，<code>有锁</code>、<code>无锁</code>的实现方式本质上都是一样的，只是层次、粒度不一样。在不同层次上实现锁导致不同的性能差异。</p>
<p>本节详述使用线程安全队列进行的方式线程间通信。然后剖析<code>queue</code>模块，根据该模块实现实现线程安全的优先队列。最后实现基于CAS的无锁队列。</p>
<p>Python<code>queue</code>模块有三个线程安全的队列，根据其命名可以知道其作用：</p>
<ul>
<li>queue.Queue</li>
<li>queue.LifoQueue</li>
<li>queue.PriorityQueue</li>
</ul>
<p>它们的接口都一致的。下面以<code>生产者/消费者</code>为例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">_sentinel = object()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></span><br><span class="line">        self.q = q</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            e = self.q.get()</span><br><span class="line">            <span class="keyword">if</span> e <span class="keyword">is</span> _sentinel:</span><br><span class="line">                self.q.put(e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(<span class="string">'consume:&#123;&#125; by thread&lt;&#123;&#125;&gt;'</span>.format(e, threading.current_thread().ident))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></span><br><span class="line">        self.q = q</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        loop = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            e = random.choice(string.ascii_letters)</span><br><span class="line">            self.q.put(e)</span><br><span class="line">            print(<span class="string">'produce:&#123;&#125; by thread&lt;&#123;&#125;&gt;'</span>.format(e, threading.current_thread().ident))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> loop == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.q.put(_sentinel)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    q = queue.Queue(maxsize=<span class="number">10</span>)</span><br><span class="line">    producer = Producer(q)</span><br><span class="line">    consumer = Consumer(q)</span><br><span class="line">    producer.start()</span><br><span class="line">    consumer.start()</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>上面的实现有一个特殊的处理，通过<code>_sentinel</code>对象告知消费者退出，当消费者收到这个对象后重新把它放到队列中，然后退出循环。</p>
<p>另外有一种方法可以不使用<code>_sentinel</code>，把消费者和生产者设置为守护线程，当队列为空时，main函数（主线程）不等待消费者和生产者进程而直接退出，进而程序退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></span><br><span class="line">        self.q = q</span><br><span class="line">        super().__init__(daemon=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            e = self.q.get()</span><br><span class="line">            print(<span class="string">'consume:&#123;&#125; by thread&lt;&#123;&#125;&gt;'</span>.format(e, threading.current_thread().ident))</span><br><span class="line">            self.q.task_done()</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></span><br><span class="line">        self.q = q</span><br><span class="line">        super().__init__(daemon=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            e = random.choice(string.ascii_letters)</span><br><span class="line">            self.q.put(e)</span><br><span class="line">            print(<span class="string">'produce:&#123;&#125; by thread&lt;&#123;&#125;&gt;'</span>.format(e, threading.current_thread().ident))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    q = queue.Queue(maxsize=<span class="number">10</span>)</span><br><span class="line">    producer = Producer(q)</span><br><span class="line">    consumer = Consumer(q)</span><br><span class="line">    producer.start()</span><br><span class="line">    consumer.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>) <span class="comment"># 避免队列一开始为空而直接退出</span></span><br><span class="line">    q.join()</span><br><span class="line">    print(<span class="string">'queue is empty, so quit'</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>在不采取主动终止的情况，上面的代码不确定何时终止，就像网络爬虫并不能确定何时检索完整个网络。这个问题融入一定的技巧可以解决，文章后面会提及。</p>
<p>关于线程通信的深入探讨见旧文<a href>线程安全的优先队列的实现</a>。</p>
<p>转载请包括本文地址：<a href="../4871">https://allenwind.github.io/blog/4871</a><br>更多文章请参考：<a href="../archives/">https://allenwind.github.io/blog/archives/</a></p>
</div><div class="tags"><a href="/blog/tags/Python/">Python</a><a href="/blog/tags/并发编程/">并发编程</a></div><div class="post-nav"><a class="pre" href="/blog/4940/">Vim学习笔记</a><a class="next" href="/blog/4833/">Flask应用的部署</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://allenwind.github.io/blog"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/NLP/">NLP</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据结构和算法/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/机器学习深度学习/">机器学习深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/记录/">记录</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/算法/" style="font-size: 15px;">算法</a> <a href="/blog/tags/C/" style="font-size: 15px;">C</a> <a href="/blog/tags/Python/" style="font-size: 15px;">Python</a> <a href="/blog/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/blog/tags/C语言/" style="font-size: 15px;">C语言</a> <a href="/blog/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/blog/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/blog/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/blog/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/blog/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/blog/tags/sudo/" style="font-size: 15px;">sudo</a> <a href="/blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/blog/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/blog/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/blog/tags/git/" style="font-size: 15px;">git</a> <a href="/blog/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/blog/tags/Git/" style="font-size: 15px;">Git</a> <a href="/blog/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/blog/tags/Systemd/" style="font-size: 15px;">Systemd</a> <a href="/blog/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/blog/tags/gcc/" style="font-size: 15px;">gcc</a> <a href="/blog/tags/网络/" style="font-size: 15px;">网络</a> <a href="/blog/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/blog/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/blog/tags/记录/" style="font-size: 15px;">记录</a> <a href="/blog/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/blog/tags/Go/" style="font-size: 15px;">Go</a> <a href="/blog/tags/go/" style="font-size: 15px;">go</a> <a href="/blog/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/blog/tags/ARC/" style="font-size: 15px;">ARC</a> <a href="/blog/tags/Java/" style="font-size: 15px;">Java</a> <a href="/blog/tags/搜索引擎/" style="font-size: 15px;">搜索引擎</a> <a href="/blog/tags/剑指Offer/" style="font-size: 15px;">剑指Offer</a> <a href="/blog/tags/函数式/" style="font-size: 15px;">函数式</a> <a href="/blog/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/blog/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/blog/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/blog/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/blog/tags/并发/" style="font-size: 15px;">并发</a> <a href="/blog/tags/装饰器/" style="font-size: 15px;">装饰器</a> <a href="/blog/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/blog/tags/数学/" style="font-size: 15px;">数学</a> <a href="/blog/tags/时间序列/" style="font-size: 15px;">时间序列</a> <a href="/blog/tags/投资/" style="font-size: 15px;">投资</a> <a href="/blog/tags/概率/" style="font-size: 15px;">概率</a> <a href="/blog/tags/统计/" style="font-size: 15px;">统计</a> <a href="/blog/tags/信息论/" style="font-size: 15px;">信息论</a> <a href="/blog/tags/度量/" style="font-size: 15px;">度量</a> <a href="/blog/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/blog/tags/贝叶斯/" style="font-size: 15px;">贝叶斯</a> <a href="/blog/tags/最小二乘法/" style="font-size: 15px;">最小二乘法</a> <a href="/blog/tags/分布/" style="font-size: 15px;">分布</a> <a href="/blog/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/blog/tags/变分推断/" style="font-size: 15px;">变分推断</a> <a href="/blog/tags/随机/" style="font-size: 15px;">随机</a> <a href="/blog/tags/不等式/" style="font-size: 15px;">不等式</a> <a href="/blog/tags/采样/" style="font-size: 15px;">采样</a> <a href="/blog/tags/光滑/" style="font-size: 15px;">光滑</a> <a href="/blog/tags/逼近/" style="font-size: 15px;">逼近</a> <a href="/blog/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/blog/tags/交叉验证/" style="font-size: 15px;">交叉验证</a> <a href="/blog/tags/特征工程/" style="font-size: 15px;">特征工程</a> <a href="/blog/tags/集成学习/" style="font-size: 15px;">集成学习</a> <a href="/blog/tags/分类/" style="font-size: 15px;">分类</a> <a href="/blog/tags/证明/" style="font-size: 15px;">证明</a> <a href="/blog/tags/损失函数/" style="font-size: 15px;">损失函数</a> <a href="/blog/tags/回归/" style="font-size: 15px;">回归</a> <a href="/blog/tags/正则化/" style="font-size: 15px;">正则化</a> <a href="/blog/tags/词向量/" style="font-size: 15px;">词向量</a> <a href="/blog/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/blog/tags/信息/" style="font-size: 15px;">信息</a> <a href="/blog/tags/Embedding/" style="font-size: 15px;">Embedding</a> <a href="/blog/tags/神经网络/" style="font-size: 15px;">神经网络</a> <a href="/blog/tags/Transformer/" style="font-size: 15px;">Transformer</a> <a href="/blog/tags/Attention/" style="font-size: 15px;">Attention</a> <a href="/blog/tags/对抗训练/" style="font-size: 15px;">对抗训练</a> <a href="/blog/tags/文本分类/" style="font-size: 15px;">文本分类</a> <a href="/blog/tags/分词/" style="font-size: 15px;">分词</a> <a href="/blog/tags/并行/" style="font-size: 15px;">并行</a> <a href="/blog/tags/NER/" style="font-size: 15px;">NER</a> <a href="/blog/tags/概率图/" style="font-size: 15px;">概率图</a> <a href="/blog/tags/HMM/" style="font-size: 15px;">HMM</a> <a href="/blog/tags/图/" style="font-size: 15px;">图</a> <a href="/blog/tags/可视化/" style="font-size: 15px;">可视化</a> <a href="/blog/tags/RNN/" style="font-size: 15px;">RNN</a> <a href="/blog/tags/LSTM/" style="font-size: 15px;">LSTM</a> <a href="/blog/tags/梯度/" style="font-size: 15px;">梯度</a> <a href="/blog/tags/注意力/" style="font-size: 15px;">注意力</a> <a href="/blog/tags/序列编码/" style="font-size: 15px;">序列编码</a> <a href="/blog/tags/磁盘故障/" style="font-size: 15px;">磁盘故障</a> <a href="/blog/tags/BERT/" style="font-size: 15px;">BERT</a> <a href="/blog/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/blog/tags/卷积/" style="font-size: 15px;">卷积</a> <a href="/blog/tags/优化/" style="font-size: 15px;">优化</a> <a href="/blog/tags/调参/" style="font-size: 15px;">调参</a> <a href="/blog/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/blog/tags/web/" style="font-size: 15px;">web</a> <a href="/blog/tags/socket/" style="font-size: 15px;">socket</a> <a href="/blog/tags/安全/" style="font-size: 15px;">安全</a> <a href="/blog/tags/协程/" style="font-size: 15px;">协程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/16003/">天马行空：设计自己的激活函数</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15887/">函数光滑近似（4）：Heaviside step函数及其应用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15205/">引入参数控制softmax的smooth程度</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15110/">分析与拓展：多分类模型的输出为什么使用softmax？</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14990/">一种基于光滑逼近的正态分布采样法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14721/">GELU由来：从狄拉克函数到GELU激活函数</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14465/">Lp范数的上下界分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14441/">logsumexp函数分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14133/">分析Mish激活函数的设计思路</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/13899/">阿尔法经济学：Shiller模型介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/allenwind" title="My GitHub" target="_blank">My GitHub</a><ul></ul><a href="http://www.arxiv-sanity.com/" title="arxiv-sanity" target="_blank">arxiv-sanity</a><ul></ul><a href="https://arxiv.org/" title="arxiv.org" target="_blank">arxiv.org</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/blog/." rel="nofollow">Mr.Feng Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>