<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="你好，世界！"><title>文本匹配的经典方法 | Mr.Feng Blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">文本匹配的经典方法</h1><a id="logo" href="/blog/.">Mr.Feng Blog</a><p class="description">NLP、深度学习、机器学习、Python、Go</p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">文本匹配的经典方法</h1><div class="post-meta">Nov 27, 2019<span> | </span><span class="category"><a href="/blog/categories/NLP/">NLP</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#向量表征"><span class="toc-number">1.</span> <span class="toc-text">向量表征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相似度度量"><span class="toc-number">2.</span> <span class="toc-text">相似度度量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cos相似"><span class="toc-number">3.</span> <span class="toc-text">cos相似</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#欧几里得距离"><span class="toc-number">4.</span> <span class="toc-text">欧几里得距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汉明距离"><span class="toc-number">5.</span> <span class="toc-text">汉明距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#雅可比相似"><span class="toc-number">6.</span> <span class="toc-text">雅可比相似</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cqr-amp-ctr"><span class="toc-number">7.</span> <span class="toc-text">cqr &amp; ctr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编辑距离"><span class="toc-number">8.</span> <span class="toc-text">编辑距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子字符串"><span class="toc-number">9.</span> <span class="toc-text">最长公共子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子序列"><span class="toc-number">10.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM25"><span class="toc-number">11.</span> <span class="toc-text">BM25</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于Wasserstein距离的向量序列比较"><span class="toc-number">12.</span> <span class="toc-text">基于Wasserstein距离的向量序列比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展和衍生"><span class="toc-number">13.</span> <span class="toc-text">扩展和衍生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">14.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">15.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">16.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>一文梳理文本匹配中经典的非机器学习方法，这些方法不用设计深度模型甚至不需要训练。</p>
<a id="more"></a>
<h2 id="向量表征"><a href="#向量表征" class="headerlink" title="向量表征"></a>向量表征</h2><p>文本匹配（语义相似、文本相似）的经典方法有些需要配合向量表征使用，常见的向量表征方法有：</p>
<ul>
<li>word2vec</li>
<li>tf-idf</li>
<li>VSM向量空间模型</li>
</ul>
<p>这里不展开说了。像word2vec直接获得的是词向量序列，获得句子的表征还需要一步操作，如直接求和、求平均，或者使用词的idf权重加权求和。VSM、tf-idf方法直接在句子空间中计算句子的向量表征。如果是深度模型，常见的方法有MaxPooling、AveragePooling、BERT的[CLS]等等。</p>
<p>从表征的角度看，匹配方法可以分为三类：</p>
<ul>
<li>基于文本字符的直接匹配</li>
<li>基于词向量序列的匹配</li>
<li>基于词向量序列所构造的句向量的匹配</li>
</ul>
<h2 id="相似度度量"><a href="#相似度度量" class="headerlink" title="相似度度量"></a>相似度度量</h2><p>通过句子的向量序列，获取句向量，如加权平均或直接平均。</p>
<p><a href="../6561">Minkowski距离、Mahalanobis距离、Wasserstein距离</a>中的相似方法，例如余弦相似，</p>
<p>距离度量$D$定义：</p>
<ol>
<li>$D(a,b) \ge 0$  当$a=b$取等式（非负性和正定性）</li>
<li>$D(a,b) = D(b,a)$（对称a性）</li>
<li>$D(a,b) \le D(a,z) + D(b,z)$ （三角不等式）。</li>
</ol>
<h2 id="cos相似"><a href="#cos相似" class="headerlink" title="cos相似"></a>cos相似</h2><p>假设句子对的词向量分别为A、B，那么有cos相似，</p>
<script type="math/tex; mode=display">
\cos(\theta )
=\frac{\mathbf {A} \cdot \mathbf {B}}{ \|\mathbf {A} \|\|\mathbf {B} \|}
=\frac {\sum \limits _{i=1}^{n}A_{i}B_{i}}{\sqrt {\sum \limits _{i=1}^{n}A_{i}^{2}}{\sqrt {\sum \limits _{i=1}^{n}B_{i}^{2}}}}</script><p>取值区间为$[-1, 1]$。转换成$[0,2]$正区间的相似度度量，</p>
<script type="math/tex; mode=display">
s(\theta) = 1 - \cos(\theta )</script><p>对于文本匹配任务来说，要求$A$和$B$​​表示为句向量的形式，可以使用tfidf或word2vec等等。还有一种方法就是直接对词向量序列进行加权平均，</p>
<script type="math/tex; mode=display">
\operatorname{average}(x)=
\frac {\sum \limits _{i=1}^{n}w_{i}x_{i}}{\sum \limits _{i=1}^{n}w_{i}}</script><p>然后权重可以是等全，即直接相加平均，或者取值为词$x_i$的idf值。</p>
<p>需要注意，从距离度量上看，$\cos(\theta )$不满足三角不等式。</p>
<h2 id="欧几里得距离"><a href="#欧几里得距离" class="headerlink" title="欧几里得距离"></a>欧几里得距离</h2><p>假设两个随机向量分别为$X=(x_{1},x_{2},\ldots ,x_{n})\in {\mathbb  {R}}^{n}$和$Y=(y_{1},y_{2},\ldots ,y_{n})\in {\mathbb  {R}}^{n}$，那么他们之间的闵可夫斯基距离为，</p>
<script type="math/tex; mode=display">
d\left(X,Y\right)=\left(\sum _{i=1}^{n}|x_{i}-y_{i}|^{p}\right)^{\frac {1}{p}}</script><p>其中$p \ge 1$。欧几里得距离是Minkowski（闵可夫斯基）距离$p=2$的情况，即</p>
<script type="math/tex; mode=display">
d\left(X,Y\right)=\left(\sum _{i=1}^{n}|x_{i}-y_{i}|^{2}\right)^{\frac {1}{2}}</script><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>汉明距离是Minkowski（闵可夫斯基）距离$p=0$​的情况。在文本处理中，其含义是，两个等长字符串的汉明距离是指两者对应位置的不同字符的个数。比如“funny”和“denny”的汉明距离是2。在文本相似中，可以作为特征使用，单独使用效果并不好。</p>
<p>Python实现如下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span><span class="params">(text1, text2)</span>:</span></span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(text1)):</span><br><span class="line">        <span class="keyword">if</span> text1[n] != text2[n]:</span><br><span class="line">            d += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<h2 id="雅可比相似"><a href="#雅可比相似" class="headerlink" title="雅可比相似"></a>雅可比相似</h2><p>雅可比（Jaccard）相似系数，</p>
<script type="math/tex; mode=display">
J(A,B)=\frac{|A\cap B|}{|A\cup B|}= \frac{|A\cap B|}{|A|+|B|-|A\cap B|}</script><p>可以作为文本的重合度的度量。Python实现如下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jaccard_similar</span><span class="params">(text1, text2)</span>:</span></span><br><span class="line">    words1 = jieba.lcut(text1)</span><br><span class="line">    words2 = jieba.lcut(text2)</span><br><span class="line">    s1 = set(words1)</span><br><span class="line">    s2 = set(words2)</span><br><span class="line">    <span class="keyword">return</span> len(s1.intersection(s2)) / len(s1.union(s2))</span><br></pre></td></tr></table></figure>
<p>考虑到不同词汇的重要性不同，如果直接按照集合大小不加以区分，效果会不准确，因此可以引入词汇权重信息，加权句子间的区分，详细可参看本文<a href="#扩展和衍生">扩展和衍生</a>部分。</p>
<h2 id="cqr-amp-ctr"><a href="#cqr-amp-ctr" class="headerlink" title="cqr &amp; ctr"></a>cqr &amp; ctr</h2><p>考虑query和title的匹配，query和title两者交集占query的比例，</p>
<script type="math/tex; mode=display">
\operatorname{sim}_{cqr}(Q, T) = \frac{\vert Q \cap T \vert}{\vert Q \vert}</script><p>query和title两者交集占title的比例，</p>
<script type="math/tex; mode=display">
\operatorname{sim}_{ctr}(Q, T) = \frac{\vert Q \cap T \vert}{\vert T \vert}</script><p>两者相乘可以获得对称的相似计算公式，</p>
<script type="math/tex; mode=display">
\begin{align}
\operatorname{sim}(Q, T) 
&= \operatorname{sim}_{cqr}(Q, T) \times \operatorname{sim}_{ctr}(Q, T) \newline
&= \frac{\vert Q \cap T \vert ^{2}}{\vert Q \vert \vert T \vert}

\end{align}</script><p>所谓的对称就是$\operatorname{sim}(Q, T)  = \operatorname{sim}(T, Q) $​。</p>
<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>编辑距离（Levenshitein distance）是给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。编辑距离计算将字符串转换成另一个字符串的操作步骤数量来独立字符串的距离，它的值越高，表示两个字符串越不相似，反之则反。</p>
<p>$\operatorname {L} _{a,b}(i,j)$表示字符$a_{&lt;i}$和字符$b_{&lt;j}$的编辑距离</p>
<p>编辑距离可以看做是汉明距离的一般形式，支持不等长字符串，其递归表达如下，</p>
<script type="math/tex; mode=display">
\qquad \operatorname {Ld} _{a,b}(i,j)=
\begin{cases}
\max(i,j)&\;\text{ if }\min(i,j)=0\\
\min \begin{cases}\operatorname {Ld} _{a,b}(i-1,j)+1\\
\operatorname {Ld} _{a,b}(i,j-1)+1\\
\operatorname {Ld} _{a,b}(i-1,j-1)+\mathbb{I}[a_{i}\neq b_{j}]
\end{cases} &\;\text{ otherwise.}
\end{cases}</script><p>其中$\mathbb{I}[a_{i}\neq b_{j}]$值指示函数。</p>
<p>对于不存在空字符串的情况</p>
<script type="math/tex; mode=display">
\qquad \operatorname {L} _{a,b}(i,j)=
\min \begin{cases}\operatorname {L} _{a,b}(i-1,j)+1\\
\operatorname {L} _{a,b}(i,j-1)+1\\
\operatorname {L} _{a,b}(i-1,j-1)+\mathbb{I}[a_{i}\neq b_{j}]
\end{cases}</script><p>最后获得的编辑距离归一化后可以作为文本相似性的度量。使用Python表示为，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_editdistance_similar</span><span class="params">(text1, text2)</span>:</span></span><br><span class="line">    <span class="string">"""根据编辑距离的归一化值作为相似性度量"""</span></span><br><span class="line">    distance = min_edit_distance(text1, text2)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - distance / max(len(text1), len(text2))</span><br></pre></td></tr></table></figure>
<p>更详细的实现可参看我的Github：<a href="https://github.com/allenwind/text-similarity-classical-methods。" target="_blank" rel="noopener">https://github.com/allenwind/text-similarity-classical-methods。</a></p>
<h2 id="最长公共子字符串"><a href="#最长公共子字符串" class="headerlink" title="最长公共子字符串"></a>最长公共子字符串</h2><p><strong>最长公共子串问题（Longest common substring problem）</strong>类似最长公共子序列，其中要求<strong>子串</strong>在原序列中占用连续的位置。</p>
<script type="math/tex; mode=display">
l(i,j) = l(i-1, j-1) + 1 \; \text{ if } a_i = b_j</script><p>最长公共子串列长度与两个序列中最长的长度的比值作为这两个序列的相似性度量，即，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcsubstring_similar</span><span class="params">(text1, text2)</span>:</span></span><br><span class="line">    <span class="string">"""根据最长公共子串的归一化值作为相似性度量"""</span></span><br><span class="line">    *_, distance = longest_common_substring(text1, text2)</span><br><span class="line">    <span class="keyword">return</span> distance / max(len(text1), len(text2))</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><strong>最长公共子序列</strong>（<strong>LCS</strong>）问题是找到两个或多个序列中共有的最长子序列，其中子序列不要求在原序列中占用连续的位置。</p>
<p>$l(i,j)$表示序列$a_{&lt;i}$和序列$b_{&lt;j}$的最长公共子序列长度</p>
<script type="math/tex; mode=display">
l(i,j) = \begin{cases}
l(i-1,j-1) + 1 &  \text{ if } a_i = b_j\\
\max(l(i,j-1), l(i-1,j)) & \text{ if } a_i \ne b_j
\end{cases}</script><p>最长公共子序列长度与两个序列中最长的长度的比值作为这两个序列的相似性度量，即，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs_similar</span><span class="params">(text1, text2)</span>:</span></span><br><span class="line">    <span class="string">"""根据最长公共子序列的归一化值作为相似性度量"""</span></span><br><span class="line">    *_, distance = longest_common_subsequence(text1, text2)</span><br><span class="line">    <span class="keyword">return</span> distance / max(len(text1), len(text2))</span><br></pre></td></tr></table></figure>
<h2 id="BM25"><a href="#BM25" class="headerlink" title="BM25"></a>BM25</h2><p>文本匹配中代表性模型有 BM25，对于句子$Q = [q_1, \dots, q_n]$，每个要比较的句子D，其匹配度为，</p>
<script type="math/tex; mode=display">
\displaystyle {\text{score}}(Q, D)=\sum _{i=1}^{n}{\text{IDF}}(q_{i})\cdot {\frac {f(q_{i},D)\cdot (k_{1}+1)}{f(q_{i},D)+k_{1}\cdot \left(1-b+b\cdot {\frac {|D|}{\text{avgdl}}}\right)}}</script><p>其中，</p>
<script type="math/tex; mode=display">
\text{IDF}(q_i) =\log \frac{N - n(q_i) + 0.5}{n(q_i) + 0.5}</script><p>当然，比较方便的做法是词$q_i$的IDF值直接在idf词典中获取。</p>
<p>$\text{avgdl}$表示文本的平均常见，$b$和$k_1$是超参数，根据经验调节。$f(q_{i},D)$为句子Q中的词$q_i$​与句子D的匹配度，这里使用词$q_i$在句子D中出现的频率来表示。</p>
<p>事实上，结合jieba分词，BM25的Python实现比上式清晰多了，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bm25_similar</span><span class="params">(text1, text2, s_avg=<span class="number">10</span>, k1=<span class="number">2.0</span>, b=<span class="number">0.75</span>)</span>:</span></span><br><span class="line">    <span class="string">"""s_avg是句子的平均长度，根据语料统计。k1,b是调节因子，根据经验调整。"""</span></span><br><span class="line">    bm25 = <span class="number">0.0</span></span><br><span class="line">    sl = len(text2)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> jieba.lcut(text1):</span><br><span class="line">        w_idf = idf_dict.get(w, <span class="number">1</span>)</span><br><span class="line">        bm25_ra = text2.count(w) * (k1 + <span class="number">1</span>)</span><br><span class="line">        bm25_rb = text2.count(w) + k1 * (<span class="number">1</span> - b + b * sl / s_avg)</span><br><span class="line">        bm25 += w_idf * bm25_ra / bm25_rb</span><br><span class="line">    <span class="keyword">return</span> bm25</span><br></pre></td></tr></table></figure>
<p>注意到，这里的实现需要事先准备好idf词典。在实践中，需要注意idf词典与句子对集的match程度。</p>
<h2 id="基于Wasserstein距离的向量序列比较"><a href="#基于Wasserstein距离的向量序列比较" class="headerlink" title="基于Wasserstein距离的向量序列比较"></a>基于Wasserstein距离的向量序列比较</h2><p>Wasserstein距离在文章<a href="../6561/">Minkowski距离、Mahalanobis距离、Wasserstein距离</a>中以及有简明的介绍。</p>
<p>句子的向量序列容易获得，如gensim加载word2vec模型，甚至BERT等模型。现有句子1的向量序列，</p>
<script type="math/tex; mode=display">
s_{1} = [\boldsymbol{\phi}_{1},\dots,\boldsymbol{\phi}_{m}]</script><p>类似地，句子2的向量序列，</p>
<script type="math/tex; mode=display">
s_{2} = [\boldsymbol{\psi}_{1},\dots,\boldsymbol{\psi}_{n}]</script><p>注意到一般情况下$m \ne n$</p>
<p>我们使用$d_{i,j}$表示$\boldsymbol{\phi}_{i}$与$\boldsymbol{\psi}_{j}$的某种度量下的差异，如范数。$c_{i,j} \ge 0$表示把内容从$i$处移动到$j$出的量。注意到，从$i$处移动到$j=1,\dots,n$处的总量为$p_{i}$，因此有，</p>
<script type="math/tex; mode=display">
\begin{equation}
\sum_j c_{i,j}=p_i
\end{equation}</script><p>同理，</p>
<script type="math/tex; mode=display">
\sum_i c_{i,j}=q_j</script><p>因此有最优化问题，</p>
<script type="math/tex; mode=display">
\begin{align}
\min \sum_{i,j} c_{i,j}d_{i,j} \\
\text{s.t.} \; \sum_j c_{i,j}=p_i \\
\sum_i c_{i,j}=q_j \\
c_{i,j} \ge 0
\end{align}</script><p>在运用到句子相似度计算时上时，可以取$p_i = \frac{1}{n}$以及$q_i = \frac{1}{m}$，相当于不引入任何先验假设，称为字移动距离（WMD）。实现的Python代码如下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_mover_similar</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""Word Mover's Distance计算方法, </span></span><br><span class="line"><span class="string">    x.shape=(m,d)</span></span><br><span class="line"><span class="string">    y.shape=(n,d)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = np.array(x)</span><br><span class="line">    y = np.array(y)</span><br><span class="line">    p = np.ones(x.shape[<span class="number">0</span>]) / x.shape[<span class="number">0</span>]</span><br><span class="line">    q = np.ones(y.shape[<span class="number">0</span>]) / y.shape[<span class="number">0</span>]</span><br><span class="line">    C = np.sqrt(np.mean(np.square(x[:,<span class="literal">None</span>] - y[<span class="literal">None</span>,:]), axis=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - wasserstein_distance(p, q, C)</span><br></pre></td></tr></table></figure>
<p>这一部分可以参考历史文章<a href="../6561">Minkowski距离、Mahalanobis距离、Wasserstein距离</a>。</p>
<p>字移动距离（WMD）尽管不涉及模型的训练，但是在计算上开销还是比较大，但是其建模上的优雅，不失作为一个baseline或优化因子。</p>
<h2 id="扩展和衍生"><a href="#扩展和衍生" class="headerlink" title="扩展和衍生"></a>扩展和衍生</h2><p>事实上，以上基本方法可以组合起来衍生更有效的方法。例如词汇的IDF权重和雅可比相似组合起来，使用词汇的集权平均代替词汇集合的大小。</p>
<p>具体Python实现为，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weighted_jaccard_similar</span><span class="params">(text1, text2)</span>:</span></span><br><span class="line">    <span class="string">"""使用idf进行词汇加权的jaccard_similar"""</span></span><br><span class="line">    words1 = jieba.lcut(text1)</span><br><span class="line">    words2 = jieba.lcut(text2)</span><br><span class="line">    s1 = set(words1)</span><br><span class="line">    s2 = set(words2)</span><br><span class="line">    a = s1.intersection(s2)</span><br><span class="line">    b = s1.union(s2)</span><br><span class="line">    al = np.array([idf_dict.get(w, <span class="number">1</span>) <span class="keyword">for</span> w <span class="keyword">in</span> a]).sum(axis=<span class="number">0</span>)</span><br><span class="line">    bl = np.array([idf_dict.get(w, <span class="number">1</span>) <span class="keyword">for</span> w <span class="keyword">in</span> b]).sum(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> al / bl</span><br></pre></td></tr></table></figure>
<p>实现表明，这种方式比原始的雅可比相好很多，而且并没有引入诸如word2vec这类词向量。</p>
<p>类似地，cqr &amp; ctr也可以引入这种权重。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>后期整理补充了上述相关实现，可参看我的Github：<a href="https://github.com/allenwind/text-similarity-classical-methods" target="_blank" rel="noopener">https://github.com/allenwind/text-similarity-classical-methods</a> 。</p>
<p>这是后期的实现更新，包括了上述的方法的实现，以及使用PR曲线、ROC曲线对比这些方法的差异。</p>
<p>可能会根据个人需要不断更新~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上总结了很多文本匹配的经典方法，这些方法不用设计深度学习模型，甚至不用进行模型训练，在测试中取得不错的效果。在不要求高性能，追求效率的情况下，这些经典方法不失为一种尝试。</p>
<p>此外，还有句子向量表征召回方法，就是把句子向量化，通过一定的技术对其进行索引，召回时，搜索其进邻向量即可。还有就是深度模型，如DSSM及其各自扩展。这些后期有机会在深入展开。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://arxiv.org/abs/1902.07285" target="_blank" rel="noopener">From Word Embeddings To Document Distances</a></p>
<p>[2] 《统计自然语言处理》</p>
<p>转载请包括本文地址：<a href="../11001">https://allenwind.github.io/blog/11001</a><br>更多文章请参考：<a href="../archives/">https://allenwind.github.io/blog/archives/</a></p>
</div><div class="tags"><a href="/blog/tags/Python/">Python</a><a href="/blog/tags/NLP/">NLP</a></div><div class="post-nav"><a class="pre" href="/blog/11065/">Linux系统中安装多版本gcc</a><a class="next" href="/blog/10951/">时间序列的特征工程详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://allenwind.github.io/blog"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/NLP/">NLP</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据结构和算法/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/机器学习深度学习/">机器学习深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/记录/">记录</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/算法/" style="font-size: 15px;">算法</a> <a href="/blog/tags/C/" style="font-size: 15px;">C</a> <a href="/blog/tags/Python/" style="font-size: 15px;">Python</a> <a href="/blog/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/blog/tags/C语言/" style="font-size: 15px;">C语言</a> <a href="/blog/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/blog/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/blog/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/blog/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/blog/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/blog/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/blog/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/blog/tags/sudo/" style="font-size: 15px;">sudo</a> <a href="/blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/blog/tags/git/" style="font-size: 15px;">git</a> <a href="/blog/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/blog/tags/Git/" style="font-size: 15px;">Git</a> <a href="/blog/tags/gcc/" style="font-size: 15px;">gcc</a> <a href="/blog/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/blog/tags/Systemd/" style="font-size: 15px;">Systemd</a> <a href="/blog/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/blog/tags/网络/" style="font-size: 15px;">网络</a> <a href="/blog/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/blog/tags/记录/" style="font-size: 15px;">记录</a> <a href="/blog/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/blog/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/blog/tags/Go/" style="font-size: 15px;">Go</a> <a href="/blog/tags/go/" style="font-size: 15px;">go</a> <a href="/blog/tags/Java/" style="font-size: 15px;">Java</a> <a href="/blog/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/blog/tags/ARC/" style="font-size: 15px;">ARC</a> <a href="/blog/tags/搜索引擎/" style="font-size: 15px;">搜索引擎</a> <a href="/blog/tags/剑指Offer/" style="font-size: 15px;">剑指Offer</a> <a href="/blog/tags/函数式/" style="font-size: 15px;">函数式</a> <a href="/blog/tags/Stack/" style="font-size: 15px;">Stack</a> <a href="/blog/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/blog/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/blog/tags/并发/" style="font-size: 15px;">并发</a> <a href="/blog/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/blog/tags/装饰器/" style="font-size: 15px;">装饰器</a> <a href="/blog/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/blog/tags/数学/" style="font-size: 15px;">数学</a> <a href="/blog/tags/度量/" style="font-size: 15px;">度量</a> <a href="/blog/tags/时间序列/" style="font-size: 15px;">时间序列</a> <a href="/blog/tags/投资/" style="font-size: 15px;">投资</a> <a href="/blog/tags/概率/" style="font-size: 15px;">概率</a> <a href="/blog/tags/统计/" style="font-size: 15px;">统计</a> <a href="/blog/tags/信息论/" style="font-size: 15px;">信息论</a> <a href="/blog/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/blog/tags/贝叶斯/" style="font-size: 15px;">贝叶斯</a> <a href="/blog/tags/最小二乘法/" style="font-size: 15px;">最小二乘法</a> <a href="/blog/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/blog/tags/变分推断/" style="font-size: 15px;">变分推断</a> <a href="/blog/tags/随机/" style="font-size: 15px;">随机</a> <a href="/blog/tags/不等式/" style="font-size: 15px;">不等式</a> <a href="/blog/tags/采样/" style="font-size: 15px;">采样</a> <a href="/blog/tags/光滑/" style="font-size: 15px;">光滑</a> <a href="/blog/tags/分布/" style="font-size: 15px;">分布</a> <a href="/blog/tags/逼近/" style="font-size: 15px;">逼近</a> <a href="/blog/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/blog/tags/特征工程/" style="font-size: 15px;">特征工程</a> <a href="/blog/tags/词向量/" style="font-size: 15px;">词向量</a> <a href="/blog/tags/信息/" style="font-size: 15px;">信息</a> <a href="/blog/tags/交叉验证/" style="font-size: 15px;">交叉验证</a> <a href="/blog/tags/集成学习/" style="font-size: 15px;">集成学习</a> <a href="/blog/tags/分类/" style="font-size: 15px;">分类</a> <a href="/blog/tags/证明/" style="font-size: 15px;">证明</a> <a href="/blog/tags/损失函数/" style="font-size: 15px;">损失函数</a> <a href="/blog/tags/回归/" style="font-size: 15px;">回归</a> <a href="/blog/tags/正则化/" style="font-size: 15px;">正则化</a> <a href="/blog/tags/指标/" style="font-size: 15px;">指标</a> <a href="/blog/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/blog/tags/Embedding/" style="font-size: 15px;">Embedding</a> <a href="/blog/tags/神经网络/" style="font-size: 15px;">神经网络</a> <a href="/blog/tags/Transformer/" style="font-size: 15px;">Transformer</a> <a href="/blog/tags/Attention/" style="font-size: 15px;">Attention</a> <a href="/blog/tags/对抗训练/" style="font-size: 15px;">对抗训练</a> <a href="/blog/tags/文本分类/" style="font-size: 15px;">文本分类</a> <a href="/blog/tags/分词/" style="font-size: 15px;">分词</a> <a href="/blog/tags/并行/" style="font-size: 15px;">并行</a> <a href="/blog/tags/NER/" style="font-size: 15px;">NER</a> <a href="/blog/tags/概率图/" style="font-size: 15px;">概率图</a> <a href="/blog/tags/图/" style="font-size: 15px;">图</a> <a href="/blog/tags/HMM/" style="font-size: 15px;">HMM</a> <a href="/blog/tags/可视化/" style="font-size: 15px;">可视化</a> <a href="/blog/tags/RNN/" style="font-size: 15px;">RNN</a> <a href="/blog/tags/LSTM/" style="font-size: 15px;">LSTM</a> <a href="/blog/tags/梯度/" style="font-size: 15px;">梯度</a> <a href="/blog/tags/注意力/" style="font-size: 15px;">注意力</a> <a href="/blog/tags/序列编码/" style="font-size: 15px;">序列编码</a> <a href="/blog/tags/磁盘故障/" style="font-size: 15px;">磁盘故障</a> <a href="/blog/tags/BERT/" style="font-size: 15px;">BERT</a> <a href="/blog/tags/CNN/" style="font-size: 15px;">CNN</a> <a href="/blog/tags/卷积/" style="font-size: 15px;">卷积</a> <a href="/blog/tags/优化/" style="font-size: 15px;">优化</a> <a href="/blog/tags/调参/" style="font-size: 15px;">调参</a> <a href="/blog/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/blog/tags/web/" style="font-size: 15px;">web</a> <a href="/blog/tags/socket/" style="font-size: 15px;">socket</a> <a href="/blog/tags/安全/" style="font-size: 15px;">安全</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/16113/">Tensorflow的多卡训练：原理和实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/16051/">机器学习之分类问题的评估指标总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/16003/">天马行空：设计自己的激活函数</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15887/">函数光滑近似（4）：Heaviside step函数及其应用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15205/">引入参数控制softmax的smooth程度</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/15110/">分析与拓展：多分类模型的输出为什么使用softmax？</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14990/">一种基于光滑逼近的正态分布采样法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14721/">GELU由来：从狄拉克函数到GELU激活函数</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14465/">Lp范数的上下界分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/14441/">logsumexp函数分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/allenwind" title="My GitHub" target="_blank">My GitHub</a><ul></ul><a href="http://www.arxiv-sanity.com/" title="arxiv-sanity" target="_blank">arxiv-sanity</a><ul></ul><a href="https://arxiv.org/" title="arxiv.org" target="_blank">arxiv.org</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/blog/." rel="nofollow">Mr.Feng Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>